import numpy as np
import pandas as pd
import yfinance as yf
import streamlit as st

def normalize_ticker(t: str) -> str:
    # fixes mac "ˆ" vs "^"
    return t.strip().upper().replace("ˆ", "^")

@st.cache_data(show_spinner=False)
def download_close(tickers, start, end):
    df = yf.download(
        tickers,
        start=start,
        end=end,
        progress=False,
        auto_adjust=False,
        group_by="column",
        threads=True,
    )

    if df is None or len(df) == 0:
        raise ValueError("No data returned. Check tickers/date range.")

    # If single ticker -> columns like ['Open','High',...]
    if not isinstance(df.columns, pd.MultiIndex):
        col = "Adj Close" if "Adj Close" in df.columns else "Close"
        out = df[[col]].rename(columns={col: tickers[0]})
        return out.dropna()

    # Multi ticker -> multiindex columns: ('Adj Close', 'AAPL') etc.
    level0 = df.columns.get_level_values(0)
    use_field = "Adj Close" if "Adj Close" in level0 else "Close"
    out = df[use_field].copy()
    out = out.dropna(how="all")
    out.columns = [str(c) for c in out.columns]
    return out

st.set_page_config(page_title="Quantify — Ticker Selector", layout="wide")
st.title("Ticker Selector (like tags) + Year Range")

# ---- Sidebar controls ----
st.sidebar.header("Controls")

this_year = pd.Timestamp.today().year
min_year = 1960
max_year = this_year

y0, y1 = st.sidebar.slider(
    "Which years are you interested in?",
    min_value=min_year,
    max_value=max_year,
    value=(max(max_year - 5, min_year), max_year),
    step=1,
)

# A starter universe (edit however you want)
popular = [
    "AAPL", "MSFT", "NVDA", "AMZN", "GOOGL", "META", "TSLA",
    "^GSPC", "^IXIC", "^DJI", "^VIX",
    "GLD", "TLT", "BTC-USD", "EURUSD=X"
]

selected = st.sidebar.multiselect(
    "Which tickers would you like to view?",
    options=popular,
    default=["AAPL", "^VIX"],
)

custom = st.sidebar.text_input(
    "Add custom tickers (comma-separated)",
    placeholder="e.g., BRK-B, ^GSPC, SPY, PETR4.SA"
)

# Merge tickers
tickers = list(selected)
if custom.strip():
    tickers += [t for t in custom.split(",") if t.strip()]

tickers = [normalize_ticker(t) for t in tickers]
tickers = sorted(list(dict.fromkeys(tickers)))  # unique, keep order-ish

st.sidebar.write("Selected:", ", ".join(tickers) if tickers else "None")

# ---- Dates ----
start = pd.Timestamp(f"{y0}-01-01")
end = pd.Timestamp(f"{y1}-12-31")

# ---- Main content ----
if not tickers:
    st.info("Pick at least 1 ticker on the left.")
    st.stop()

try:
    px = download_close(tickers, start, end)
except Exception as e:
    st.error(f"Download error: {e}")
    st.stop()

# If some tickers missing, drop empty columns
px = px.dropna(axis=1, how="all")
available = list(px.columns)

missing = [t for t in tickers if t not in available]
if missing:
    st.warning(f"These tickers returned no data and were skipped: {', '.join(missing)}")

if px.shape[1] == 0:
    st.error("No usable data after download. Try other tickers/date range.")
    st.stop()

# Normalize to 100 at start (common dates)
px = px.dropna(how="any")  # align on common dates
norm = 100 * (px / px.iloc[0])

# Log returns
rets = np.log(px / px.shift(1)).dropna()

st.subheader("Normalized price (start = 100)")
st.line_chart(norm)

st.subheader("Daily log returns")
st.line_chart(rets * 100)

# Rolling correlation (only makes sense if 2+ tickers)
if rets.shape[1] >= 2:
    st.subheader("Rolling correlation (choose 2 tickers)")
    c1, c2, c3 = st.columns([1, 1, 1])

    with c1:
        tA = st.selectbox("Ticker A", options=list(rets.columns), index=0)
    with c2:
        tB = st.selectbox("Ticker B", options=list(rets.columns), index=min(1, len(rets.columns)-1))
    with c3:
        window = st.number_input("Window (trading days)", min_value=5, max_value=252, value=21, step=1)

    roll_corr = rets[tA].rolling(int(window)).corr(rets[tB])
    st.line_chart(roll_corr.dropna())

st.subheader("Latest prices")
latest = px.iloc[-1].sort_values(ascending=False).to_frame("Last Close/Adj Close")
st.dataframe(latest, use_container_width=True)
